"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AbstractActionHandler_1 = require("../AbstractActionHandler");
/**
 * Connects to a Postgres database using [MassiveJS](https://github.com/dmfay/massive-js). This expects that
 * the database is already migrated, including an `_index_state` table. Refer to the tests for more information.
 */
class MassiveActionHandler extends AbstractActionHandler_1.AbstractActionHandler {
    constructor(updaters, effects, massiveInstance) {
        super(updaters, effects);
        this.updaters = updaters;
        this.effects = effects;
        this.massiveInstance = massiveInstance;
    }
    handleWithState(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                this.massiveInstance.withTransaction((tx) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield handle(tx);
                        resolve(tx);
                    }
                    catch (err) {
                        reject();
                    }
                }), {
                    mode: new this.massiveInstance.pgp.txMode.TransactionMode({
                        tiLevel: this.massiveInstance.pgp.txMode.isolationLevel.serializable,
                    }),
                });
            });
        });
    }
    updateIndexState(state, block, isReplay) {
        return __awaiter(this, void 0, void 0, function* () {
            state._index_state.save({
                id: 0,
                block_number: block.blockNumber,
                block_hash: block.blockHash,
                is_replay: isReplay,
            });
        });
    }
    loadIndexState() {
        return __awaiter(this, void 0, void 0, function* () {
            const { blockNumber, blockHash } = yield this.massiveInstance._index_state.findOne({ id: 0 });
            if (blockNumber && blockHash) {
                return { blockNumber, blockHash };
            }
            return { blockNumber: 0, blockHash: "" };
        });
    }
    rollbackTo(blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            throw Error(`Cannot roll back to ${blockNumber}; \`rollbackTo\` not implemented.`);
        });
    }
}
exports.MassiveActionHandler = MassiveActionHandler;
