"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Takes `block`s output from implementations of `AbstractActionReader` and processes their actions through
 * `Updater`s and `Effect`s. Pass an object exposing a persistence API as `state` in the `handleWithState`
 * method. Persist and retrieve information about the last block processed with `updateIndexState` and
 * `loadIndexState`.
 */
class AbstractActionHandler {
    constructor(updaters, effects) {
        this.updaters = updaters;
        this.effects = effects;
        this.lastProcessedBlockNumber = 0;
        this.lastProcessedBlockHash = "";
    }
    /**
     * Receive block, validate, and handle actions with updaters and effects
     */
    handleBlock(block, isRollback, isFirstBlock, isReplay = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isRollback) {
                yield this.rollbackTo(block.blockNumber - 1);
            }
            if (!this.lastProcessedBlockHash && this.lastProcessedBlockNumber === 0) {
                const { blockNumber: indexStateBlockNumber, blockHash: indexStateBlockHash } = yield this.loadIndexState();
                if (indexStateBlockNumber && indexStateBlockHash) {
                    this.lastProcessedBlockNumber = indexStateBlockNumber;
                    this.lastProcessedBlockHash = indexStateBlockHash;
                }
            }
            const nextBlockNeeded = this.lastProcessedBlockNumber + 1;
            // Just processed this block; skip
            if (block.blockNumber === this.lastProcessedBlockNumber
                && block.blockHash === this.lastProcessedBlockHash) {
                return [false, 0];
            }
            // If it's the first block but we've already processed blocks, seek to next block
            if (isFirstBlock && this.lastProcessedBlockHash) {
                return [true, nextBlockNeeded];
            }
            // Only check if this is the block we need if it's not the first block
            if (!isFirstBlock) {
                if (block.blockNumber !== nextBlockNeeded) {
                    return [true, nextBlockNeeded];
                }
                // Block sequence consistency should be handled by the ActionReader instance
                if (block.previousBlockHash !== this.lastProcessedBlockHash) {
                    throw Error("Block hashes do not match; block not part of current chain.");
                }
            }
            const handleWithArgs = (state, context = {}) => __awaiter(this, void 0, void 0, function* () {
                yield this.handleActions(state, block, context, isReplay);
            });
            yield this.handleWithState(handleWithArgs);
            return [false, 0];
        });
    }
    /**
     * Process actions against deterministically accumulating updater functions.
     */
    runUpdaters(state, block, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const { actions } = block, blockInfo = __rest(block, ["actions"]);
            for (const action of actions) {
                for (const updater of this.updaters) {
                    if (action.type === updater.actionType) {
                        const { payload } = action;
                        yield updater.updater(state, payload, blockInfo, context);
                    }
                }
            }
        });
    }
    /**
     * Process actions against asynchronous side effects.
     */
    runEffects(state, block, context) {
        const { actions } = block, blockInfo = __rest(block, ["actions"]);
        for (const action of actions) {
            for (const effect of this.effects) {
                if (action.type === effect.actionType) {
                    const { payload } = action;
                    effect.effect(state, payload, blockInfo, context);
                }
            }
        }
    }
    /**
     * Calls `runUpdaters` and `runEffects` on the given actions
     */
    handleActions(state, block, context, isReplay) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.runUpdaters(state, block, context);
            if (!isReplay) {
                this.runEffects(state, block, context);
            }
            yield this.updateIndexState(state, block, isReplay, context);
            this.lastProcessedBlockNumber = block.blockNumber;
            this.lastProcessedBlockHash = block.blockHash;
        });
    }
}
exports.AbstractActionHandler = AbstractActionHandler;
